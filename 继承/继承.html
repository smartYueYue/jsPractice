<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
// 原型链继承
// 缺点 1.引用类型的属性被所有实例共享 修改Child1 Child2也被修改  2.Child的实例（child1 child2）不能像parent传参
function Parent () {
    this.name = 'baba'
}
Parent.prototype.getName = function() {
    console.log('my name is' + this.name)
}

function Child () {
}
Child.prototype = new Parent()

var Child1 = new Child()
var Child2 = new Child()


// 借用构造函数 (经典继承)
// 优点 1.避免了引用类型的属性被所有实例共享 2.可以在 pangda tuantuan 中向 Duck 传参
// 缺点 方法都在构造函数中定义，每次创建实例都会创建一遍方法。
function Duck () {
    this.duck = 'gagaga'
}
function Panda () {
    Duck.call(this)
}
var pangda = new Panda()
pangda.duck = 'jijiji'
// console.log(pangda.duck)
var tuantuan = new Panda()
// console.log(tuantuan.duck)

// 组合继承（原型链继承和经典继承双剑合璧。）
// 融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。
function Person () {
    this.name = 'yang'
    this.color = ['yellow', 'red', 'blue']
}

function Man (name) {
    Person.call(this)
    this.name = name
}

var man1 = new Man('wang')
man1.color.push('orange')
var man2 = new Man('pan')

// class 继承
class Parent {
    constructor(value) {
        this.value = value
    }
    getName() {
        console.log(this.value)
    }
}
class Child extends Parent {
    constructor(value) {
        super(value)
    }
}
let child = new Child(1)
child.getValue() // 1
child instanceof Parent // true
</script>
</html>